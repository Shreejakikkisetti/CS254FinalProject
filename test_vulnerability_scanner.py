#!/usr/bin/env python3
import unittest
import subprocess
import time
import socket
import sys
import os
from unittest.mock import patch, MagicMock

class TestVulnerabilityScanner(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Start test servers
        cls.server_dir = os.path.join(os.path.dirname(__file__), 'hw5_server')
        cls.http_server = subprocess.Popen(['python3', 'http_server.py'], 
                                         cwd=cls.server_dir,
                                         stdout=subprocess.PIPE,
                                         stderr=subprocess.PIPE)
        cls.ssh_server = subprocess.Popen(['python3', 'ssh_server.py'],
                                        cwd=cls.server_dir,
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.PIPE)
        # Give servers time to start
        time.sleep(2)

    @classmethod
    def tearDownClass(cls):
        # Stop test servers
        cls.http_server.terminate()
        cls.ssh_server.terminate()
        cls.http_server.wait()
        cls.ssh_server.wait()

    def setUp(self):
        # Ensure ports are available
        self.ports = [8080, 2222]
        for port in self.ports:
            self.assertTrue(self.is_port_open(port), f"Port {port} is not open")
        # Create test script for no vulnerabilities test
        self.test_script = """
import vulnerability_scanner
vulnerability_scanner.scan_ports = lambda verbose: []
vulnerability_scanner.main()
"""
        with open('test_no_vulns.py', 'w') as f:
            f.write(self.test_script)

    def tearDown(self):
        # Clean up test script
        try:
            os.remove('test_no_vulns.py')
        except:
            pass

    def is_port_open(self, port):
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('127.0.0.1', port))
        sock.close()
        return result == 0

    def test_normal_output(self):
        """Test normal mode output format"""
        result = subprocess.run(['python3', 'vulnerability_scanner.py'],
                              capture_output=True,
                              text=True)
        
        # Check output format
        output_lines = result.stdout.strip().split('\n')
        for line in output_lines:
            if line:  # Skip empty lines
                # Check if line matches expected format
                self.assertRegex(line, 
                    r'^(http|ssh)://[^:]+:[^@]+@127\.0\.0\.1:\d+ success$',
                    f"Output format incorrect: {line}")

    def test_verbose_output(self):
        """Test verbose mode output"""
        result = subprocess.run(['python3', 'vulnerability_scanner.py', '-v'],
                              capture_output=True,
                              text=True)
        
        # Verbose mode should show port scanning info
        self.assertIn("Found open port:", result.stderr)
        
        # Should still have correct output format
        output_lines = result.stdout.strip().split('\n')
        for line in output_lines:
            if line:
                self.assertRegex(line, 
                    r'^(http|ssh)://[^:]+:[^@]+@127\.0\.0\.1:\d+ success$')

    def test_no_output_when_no_vulnerabilities(self):
        """Test that nothing is printed when no vulnerabilities found"""
        result = subprocess.run(['python3', 'test_no_vulns.py'],
                              capture_output=True,
                              text=True)
        
        self.assertEqual(result.stdout.strip(), "")

    def test_error_handling(self):
        """Test that errors are handled silently in normal mode"""
        result = subprocess.run(['python3', 'vulnerability_scanner.py'],
                              capture_output=True,
                              text=True)
        
        # No error messages in normal mode
        self.assertEqual(result.stderr.strip(), "")

    def test_credentials_dictionary(self):
        """Test all credentials are tried"""
        result = subprocess.run(['python3', 'vulnerability_scanner.py', '-v'],
                              capture_output=True,
                              text=True)
        
        # Check if all credentials were attempted
        stderr = result.stderr
        credentials = ['admin:admin', 'root:abc123', 'skroob:12345']
        for cred in credentials:
            self.assertIn(cred, stderr, f"Credential {cred} was not attempted")

if __name__ == '__main__':
    unittest.main()
